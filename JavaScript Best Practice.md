 ---

 [JavaScript Best Practices]
  - [UseStrict](#UseStrict)
  - [Объявление переменных в начале кода/функции](#Variable)
  - [Инициализация переменных.](#InitializationVariable)
  - [Использовать строгое сравнение.](#Сomparison)
  - [Точка с запятой](#Semicolon)
  - [Использование значений по умолчанию.](#DefaultValues )
  - [Комментарии](#Comments)
  - [Cокращённый формат записи](#Reduction)
  - [Оптимизировать циклы](#Cycles)
  - [Скрипт в конце страницы](#Scripts)
  - [классы DOM-елементов](#DOM)
 
 
 ## UseStrict
 Использование 'use strict'

 Строгий режим вносит множество изменений в работу JavaScript, от очевидных до почти незаметных (за них вы будете очень благодарны).
 При использовании `use strict` скрытые ошибки теперь будут вызывать ошибки. Теперь будут устранены ошибки, затрудняющие оптимизацию движка Javascript. Ваш код может даже работать быстрее.
 В ES5 строгий режим не является обязательным, но в ES6 он необходим для многих функций, введённых в этом стандарте.
 С подробной информацией можно ознакомиться, например, на [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode).

 ## Variable 
 Объявление переменных в начале кода/функции.

 Это считается хорошей практикой написания кода и влечёт за собой:

 + Более "чистый" код на выходе;
 + Единое место для поиска локальных переменных;
 + Возможность избежать объявления нежелательных глобальных переменных;
 + Уменьшает вероятность нежелательных повторных объявлений переменных.

 ```js
   // Объявление переменных в начале
   let firstName, lastName, yearOfBirth, currentYear, age;

   ...

   // Использование в дальнейшем
   firstName = "John";
   lastName = "Smith";

   yearOfBirth = 1984;
   currentYear = 2020;

   age = currentYear - yearOfBirth;
 ```

 Это правило может также применяться и к переменным-счётчикам в циклах:

 ```js
   // Объявление переменной-счётчика в начале
   let i;

   ...

   // Использование в дальнейшем
   for (i = 10; i > 0; i--) {
     console.log(`Осталось ${i}`)
   }
 ```

 ## InitializationVariable
 Инициализация переменных.

 Инициализация переменных при их объявлении также считается хорошей практикой и позволяет:

 + Именть более "чистый" код на выходе;
 + Инициализировать переменные в одном месте;
 + Избежать неопределённых значений;

 ```js
   // Объявление и инициализация переменных в начале кода
   let firstName = "";
   let lastName = "";
   let yearOfBirth = 0;
   let currentYear = 0;
   let age = 0;
   const hobbies = [];
   const user = {}
 ```

 ## Сomparison
 Использовать строгое сравнение.

 Операторы **нестрогого** равенства/неравенства (== или !=) будут приводить значения к одному типу перед сравнением.
 При использовании же операторов **строгого** равенства/неравенства (=== или !==) сравнение производится не только по значениям, но и по типам сравниваемых данных

 ```js
   0 == "";        // true
   1 == "1";       // true
   1 == true;      // true

   0 === "";       // false
   1 === "1";      // false
   1 === true;     // false
 ```

 ## DefaultValues 
 Использование значений по умолчанию.

 Если при вызове функции передаваемый в неё аргумент будет утерян, то ему будет присвоено значение `undefined`.
 Неопределённые значения могут нарушить логику исполнения программы, поэтому стоит использовать стандартные значения для аргументов функций.

 ```js
   function myFunction(x, y) {
     if (y === undefined) {
       y = 0;
     }
   }
 ```

 Данные значения можно указать и в момент вызова функции, если использовать синтаксис ES6:

 ```js
   myFunction(x = 1, y = 2) {
     ...
   }
 ```

 Также стоит указывать параметр `default` для конструкции **switch** (инструкции для значений, не указаных ни в одном из `case`):

 ```js
   let cars = prompt('How much cars do you have?'); 
   switch (cars) {
     case 0:
       console.log(`It's enviroment-friendly)`)
       break;
     case 1:
       console.log(`It's alright)`)
       break;
     case 2:
       console.log(`It's so good`)
       break;
     default:
       console.log(`You looks so rich)`)
   }
 ```

 ## Comments
 Комментарии.

 Комментарии - это ваши сообщения другим разработчикам (либо себе в будущем).
 Хороший код, возможно, и должен комментировать себя сам, но не факт, что каждый разработчик сможеть быстро и правильно разобрать отдельные его части в данном контексте программы.

 Для комментирования каких-либо важных вещей стоит использовать `/* */`, так как при минификации кода использование однострочных комментариев через `//` может стать проблематичным.


 ## Reduction 
 По возможности использовать сокращённый формат записи.

 Это позволит уменьшить количество кода и сделать его более "чистым"

 Теперь наглядно, старый вариант записи объектов выглядел примерно так:

 ```js
   var cow = new Object();
   cow.colour = 'brown';
   cow.commonQuestion = 'What now?';
   cow.moo = function() {
     console.log('moo');
   }
   cow.feet = 4;
   cow.accordingToLarson = 'will take over the world';
 ```

 Для каждого ключа или метода объекта необходимо прописывать его название, что может запутать, привести к случайной опечатке, или, банально, надоесть :)

 Вместо этого намного логичнее использовать литеральную нотацию объектов:

 ```js
   var cow = {
     colour: 'brown',
     commonQuestion: 'What now?',
     moo: function() {
       console.log('moo);
     },
     feet: 4,
     accordingToLarson: 'will take over the world',
   };
 ```

 Также можно использовать логические сравнения или тернарные операторы вместо конструкции `if ... else`:

 ```js
   // Тернарный оператор
   let direction;
   if(x > 100){
     direction = 1;
   } else {
     direction = -1;
   } //Bad practice

   let direction = (x > 100) ? 1 : -1; //Good practice

   //Логические операторы
   if(v){
   let x = v;
 } else {
   let x = 10;
 } //Bad practice

   let x = v || 10; //Good Practice
 ```

 ## Cycles
 Оптимизировать циклы

 Циклы могут работать весьма быстро, если описывать их правильно.
 Одна из самых распространённых ошибок - вычисление длинны массива на каждой итерации цикла:

 ```js
 const names = ['George', 'Ringo', 'Paul', 'John'];
 for (let i = 0; i < names.length; i++){
   doSomeThingWith(names[i]);
 }
 ```

 Избежать этого можно просто вынеся длинну массива в отдельную переменную:

 ```js
 const names = ['George', 'Ringo', 'Paul', 'John'];
 let j = names.length;
 for (let i = 0; i < j; i++){
   doSomeThingWith(names[i]);
 }

 //Или даже так

 const names = ['George', 'Ringo', 'Paul', 'John'];
 for (let i = 0, j = names.length; i < j; i++){
   doSomeThingWith(names[i]);
 }
 ```

 ## Scripts 
 Размещать скрипт в конце страницы

 Главная цель – сделать загрузку страницы максимально быстрой для пользователя. При загрузке скрипта браузер не может продолжить (или начать) выполнение кода, пока не загружен весь файл. Поэтому пользователь должен будет ждать дольше, чтобы заметить какой-либо прогресс (если скрипт размещается не в конце файла).

 Если у вас имеются файлы JS, единственная цель которых – добавление какой-то функциональной возможности (например, после нажатия кнопки), то стоит разместить их сразу перед закрывающим тегом body. Это безусловно относится к устоявшейся практике.

 ``` js
     <div>Last element of web-page </div>
     <script type="text/javascript" src="path/to/file.js"></script>
     <script type="text/javascript" src="path/to/anotherFile.js"></script>
   </body>
  </html>
 ```

 ## DOM 
 Воздействовать на классы DOM-елементов, а не их инлайн-стили.

 Если нужно сделать отдельные элементы страницы интерактивными, то правильнее будет воздействовать на список классов этих элементов, чем напрямую обращаться к их стилям.
 Данный подход позволяет:

 + Создать несколько паттернов (.css-классов) и однообразно воздействовать на разные DOM-элементы;
 + Быстрее редактировать/отлаживать необходимые параметры, тк они находятся в одном месте и не дублируются в JS-коде;
 + Снизить вероятность "сломать" всю вёрстку из-за разной приоритетности стилей;
 + Сократить количество кода и повысить его читабельность.

 Как пример - визуализация валидации пустой строки ввода текста (Граница должна стать красного цвета):

 **Bad practice**

 ```js
   const f = document.getElementById('mainform');
   const inputs = f.getElementsByTagName('input');
   for (let i = 0, j = inputs.length; i < j; i++){
     if (inputs[i].className === 'mandatory' && inputs.value === ''){
         inputs[i].style.borderColor = '#f00';
         inputs[i].style.borderStyle = 'solid';
         inputs[i].style.borderWidth = '1px';
     }
   }
 ```

 **Good practice**

 _CSS_

 ``` 
   .error {
     border: 1px solid red;
   }
 ```
 _JS_

 ```js
   const f = document.getElementById('mainform');
   const inputs = f.getElementsByTagName('input');
   for (let i = 0, j = inputs.length; i < j; i++){
     if (inputs[i].className === 'mandatory' && inputs.value === ''){
         inputs[i].classList.add('error');
     }
   }
 ```